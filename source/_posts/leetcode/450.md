---
title: LeetCode 450. 删除二叉搜索树中的节点
excerpt: leetcode
layout: leetcode
index_img: /img/leetcode.webp
tags:
  - code
  - leetcode
categories:
  - - note
    - leetcode
date: 2022-06-02 22:22:05
---
### 思路
将搜索二叉树结果节点的左子树挪到该节点右子树最小的节点的左子树上，再把该结果节点的右子树接到结果节点的父节点上。<br>
或者将搜索二叉树结果节点的右子树挪到该节点左子树最大的节点的右子树上，再把该结果节点的左子树接到结果节点的父节点上。
### 代码
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* deleteOneNode(TreeNode* root){
        if(root==nullptr) return root;
        if(root->right==nullptr){
            return root->left;
        }else{
            TreeNode* newRoot=root->right;
            while(newRoot->left!=nullptr){
                newRoot=newRoot->left;
            }
            newRoot->left=root->left;
            return root->right;
        }
        
    }
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(root == nullptr) return root;
        TreeNode* preRoot=nullptr;
        TreeNode* res=root;
        while(res){
            if(res->val==key) break;
            preRoot=res;
            if(res->val>key) res=res->left;
            else res=res->right;
        }
        if(res==nullptr) return root;
        else{
            if(preRoot == nullptr){
                return deleteOneNode(root);
            }else{
                if(preRoot->left&&preRoot->left==res){
                    preRoot->left=deleteOneNode(res);
                }
                if(preRoot->right&&preRoot->right==res){
                    preRoot->right=deleteOneNode(res);
                }
            }
        }
        return root;
    }
};
```
[^1]:https://leetcode.cn/problems/delete-node-in-a-bst/
[^2]:https://blog.csdn.net/Dajian1040556534/article/details/122122396